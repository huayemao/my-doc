# 第四章——变量、作用域与内存

## 执行上下文与作用域

变量或函数的执行上下文决定了它们可以访问哪些数据，以及它们的行为。

全局上下文是最外层的上下文。在浏览器中，全局上下文就是我们常说的 window 对象，因此所有通过 var 定义的全局变量和函数都会成为 window 对象的属性和方法。使用 let 和 const 的顶级声明不会定义在全局上下文中，但在作用域链解析上效果是一样的。上下文在其所有代码都执行完毕后会被销毁，包括定义在它上面的所有变量和函数（全局上下文在应用程序退出前才会被销毁，比如关闭网页或退出浏览器）。

每个上下文中定义的所有变量和函数都存在于一个其关联的**变量对象（variable object）**上。虽然无法通过代码访问变量对象，但后台处理数据会用到它。

每个函数调用都有自己的上下文。当代码执行流进入函数时，函数的上下文被推到一个上下文栈上。执行完之后，上下文栈会弹出该函数上下文，将控制权返还给之前的执行上下文。ES 程序的执行流就是通过这个上下文栈进行控制的。

上下文中的代码在**执行**的时候，会创建**变量对象的作用域链（scope chain）**，决定了各级上下文中的代码在访问变量和函数时的顺序。代码正在执行的上下文的**变量对象**始终位于作用域链的最前端。如果上下文是函数，则其**活动对象（activation object）**用作变量对象。活动对象最初只有一个定义变量：arguments。（全局上下文中没有这个变量。）作用域链中的下一个变量对象来自包含上下文，以此类推直至全局上下文；

代码执行时的标识符解析是通过沿作用域链逐级搜索标识符名称完成的。搜索过程始终从作用域链的最前端开始，然后逐级往后，直到找到标识符。（如果没有找到标识符，那么通常会报错。）

### 作用域链增强

虽然执行上下文主要有全局上下文和函数上下文两种（eval()调用内部存在第三种上下文），但某些语句会导致在作用域链前端临时添加一个上下文，在代码执行后会被删除。代码执行到 `try/catch 语句的 catch 块` 或 `with` 时，都会在作用域链前端添加一个变量对象。对 with 语句来说，会向作用域链前端添加指定的对象；对 catch 语句而言，则会创建一个新的变量对象，这个变量对象会包含要抛出的错误对象的声明。

```js
function buildUrl() {
  let qs = "?debug=true";
  with (location) { //with 语句将 location 对象作为上下文
    let url = href + qs; //。href 实际上引用的是 location.href
  }
  return url;
}
```

### 变量声明

> let 声明的变量 url，因为被限制在块级作用域，所以在 with 块之外没有定义。如果 var 声明的变量 url 会成为函数上下文的一部分，可以作为函数的值被返回；

#### for 循环中的 let 声明

```js
for (var i = 0; i < 5; ++i) {
  setTimeout(() => console.log(i), 0);
}
```

若使用 var 声明，由于 var 会被提到当前作用域的顶部，在退出循环时，迭代变量保存的是导致循环退出的值：5。在之后执行超时逻辑时，所有的 i 都是同一个最终值。

而在使用 let 声明迭代变量时，JS 引擎在后台会为每个迭代循环声明一个新的迭代变量。每个 setTimeout 引用的都是不同的变量实例，所以 console.log 输出的是我们期望的值。

```js
for (var i = 0; i < 5; ++i) {
  (function (i) {
    setTimeout(() => console.log(i), 0);
  })(i);
}
```

// 不行

```js
(function () {
  for (var i = 0; i < 5; i++) {
    setTimeout(() => console.log(i));
  }
})();
```

这种每次迭代声明一个独立变量实例的行为适用于所有风格的 for 循环，包括 for-in 和 for-of 循环。
