---
sidebar_position: 2
---

# Critical Rendering Path

网页的请求开始于 HTML 请求。服务器返回后：

1. 浏览器开始解析 HTML，将接受到的字节转换成 DOM 树。浏览器不断解析 HTML、发送请求、构建 DOM，直至 HTML 末尾。
   - 每次遇到`样式表`、`脚本`或`嵌入图片的引用`等**外部资源**的链接时都会发起请求。一些请求是阻塞的， HTML 剩余部分的解析会被阻塞直到引入的资源处理完成。
2. 浏览器会构建 CSSOM。
3. DOM 和 CSSOM 都构建完成后，浏览器构建出**渲染树**计算出所有可见内容的样式。
4. 进行 layout， 确定渲染树中所有元素的位置和大小。
5. 页面将会被绘制在屏幕上

### DOM

DOM 的构建是增量的。HTML 响应被转换成 DOM nodes，然后构成 DOM 树。节点的数量越多，关键渲染路径中的后续事件将花费的时间就越长。几个额外的节点不会有什么区别，但滥用 div（divitis）可能会导致问题。

### CSSOM

DOM 包含了页面的内容， CSSOM 包含了页面的所有样式，即**有关如何为 DOM 添加样式的信息**。 DOM 的构建是增量的，但 CSSOM 不是，**CSS 是渲染阻塞的**: 在接收到并处理完所有的 CSS 之前，浏览器会阻塞页面的渲染。**因为 CSS 规则会被覆盖，所以 CSSOM 构建完成之前页面内容不会被渲染**。CSS 有它自己的一套识别有效的 tokens 的规则。C 代表 'Cascade'。 CSS 规则会向下层叠：即解析器将 tokens 转换成节点时，其子孙节点会继承样式。正因为之后的规则可能覆盖之前的，所以 HTML 那样增量处理的特点不适用于 CSS。

#### selector performance

不太明确的选择器比明确的快。因为更明确的规则需要遍历 DOM 树中更多的节点 如 `.foo {}`比 `.bar .foo {}`快，因为第二中情况下浏览器找到 .foo 时，还需要检查 .foo 是否有 .bar 的祖先元素。但 CSS 的选择器 penalty 不怎么值得优化。针对其的性能优化可能只有微秒级的提升空间。

优化 CSS 的方法有：

- minification
- separating deferred CSS into non-blocking requests by using media queries.

https://developer.mozilla.org/en-US/docs/Learn/Performance/CSS

### Render Tree

渲染树捕获了内容和样式: DOM 树 CSSOM 树结合成为渲染树。浏览器从 DOM 树的根节点开始检查每个节点，确定哪些 CSS 规则添加到各个节点上。渲染树只捕捉可见的内容， head 部分通常不包含可见信息，于是不被包含在渲染树中。如果某个元素用 `display:none` 这个规则，则其和其子节点都不在渲染树中。

### Layout

布局取决于屏幕的尺寸。 **布局这个步骤决定元素在页面上的位置、宽高，以及元素之间的相互关系**。什么是一个元素的宽？块级元素默认有父级宽度的 100%。body 默认有 100% 的宽，意味着它占据视口的 100%。设备的宽度影响布局。`viewport` 这个元标签定义了布局视口的宽度，从而影响布局。没有此标签，浏览器使用默认视口宽度，默认全屏浏览器的宽度是 960px。在默认全屏的浏览器，如手机浏览器中，通过设置 `<meta name="viewport" content="width=device-width">`, 宽度将会是设备的宽度而不是默认的视窗宽度。每次设备旋转或浏览器大小发生改变时会发生布局。

布局的性能受 DOM 影响 -- 节点数量越多， 布局花费的时间越长。如果再滚动和其他动画时需要进行布局，可能成为性能瓶颈导致卡顿。20ms 的延迟在加载或屏幕方向改变时可能还好，但在动画或滚动时就会显得卡顿。每当添加节点、改变内容，或更新节点上的**盒模型样式**导致了渲染树变化时，布局就会发生。

为了减小布局事件的频率和时长，应该进行批量更新，并避免对`盒模型属性`应用动画。

### Paint

渲染树构建完成，并进行了布局之后，像素就可以被绘制在屏幕上。加载时，整个屏幕被绘制，此后只有受影响的屏幕区域会被重绘，因为浏览器被优化到只重回所需的最小区域。绘制时间取决于何种更新应用到了渲染树。虽然绘制是非常快的步骤，不太可能成为性能优化中最值得关注的地方，但需要记住，测量一个动画帧需要的时间需要考虑到布局和重绘时间。添加每个节点的样式会增加渲染时间，但是移除样式增加的 0.001ms 或许不能让你的优化物有所值。记住先测量。然后你可决定它是否该成为一个优化项。

### CRP 的优化

通过为加载的资源**划分优先级**、**控制它们加载的顺序**和**减小这些资源的体积**，来提升页面加载速度，性能优化的要点包含

1. 通过推迟下载、让其异步加载来最小化关键资源的数量，
2. 优化必须的请求数量和每个请求的文件体积，
3. 通过区分关键资源的优先级来优化被加载关键资源的顺序，来缩短关键路径长度。

https://developer.mozilla.org/en-US/docs/Web/Performance/Critical_rendering_path
